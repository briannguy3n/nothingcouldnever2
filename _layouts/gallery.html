---
layout: no-header
---

<div class="gallery-content">
  <h1>{{ page.title }}</h1>
  
  <div class="gallery-grid">
    {% assign gallery_files = site.static_files %}
    {% for file in gallery_files %}
      {% assign file_path = file.path | downcase %}
      {% if file_path contains 'assets/img/gallery/' %}
        {% if file.extname == '.jpg' or file.extname == '.jpeg' or file.extname == '.png' or file.extname == '.gif' or file.extname == '.webp' %}
          {% assign description = page.descriptions[file.name] %}
          <div class="gallery-item" data-modified="{{ file.modified_time | date: '%s' }}">
            <img data-src="{{ site.baseurl }}{{ file.path }}" 
                 alt="" 
                 class="gallery-thumbnail lazy-image"
                 data-full="{{ site.baseurl }}{{ file.path }}"
                 data-description="{{ description }}"
                 loading="lazy">
          </div>
        {% endif %}
      {% endif %}
    {% endfor %}
  </div>
</div>

<!-- Lightbox Modal -->
<div id="lightbox" class="lightbox">
  <span class="lightbox-close">&times;</span>
  <img class="lightbox-content" id="lightbox-img">
  <div class="lightbox-caption" id="lightbox-caption"></div>
  <a class="lightbox-prev">&#10094;</a>
  <a class="lightbox-next">&#10095;</a>
</div>

<script src="{{ site.baseurl }}/assets/js/lightbox.js"></script>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // Sort gallery items by modification time (newest first)
    const gallery = document.querySelector('.gallery-grid');
    if (gallery) {
      const items = Array.from(gallery.children);
      items.sort((a, b) => {
        const timeA = parseInt(a.getAttribute('data-modified')) || 0;
        const timeB = parseInt(b.getAttribute('data-modified')) || 0;
        return timeB - timeA; // Sort descending (newest first)
      });
      items.forEach(item => gallery.appendChild(item));
    }
    
    // Random shuffle code (commented out for chronological sorting)
    // const gallery = document.querySelector('.gallery-grid');
    // const items = Array.from(gallery.children);
    // 
    // // Fisher-Yates shuffle algorithm
    // for (let i = items.length - 1; i > 0; i--) {
    //   const j = Math.floor(Math.random() * (i + 1));
    //   [items[i], items[j]] = [items[j], items[i]];
    // }
    // 
    // // Re-append items in shuffled order
    // items.forEach(item => gallery.appendChild(item));
    
    // Lazy loading with Intersection Observer
    const lazyImages = document.querySelectorAll('.lazy-image');
    
    // Configuration for the observer
    const imageObserverOptions = {
      root: null, // viewport
      rootMargin: '50px', // start loading 50px before image enters viewport
      threshold: 0.01
    };
    
    // Callback function when image intersects
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          const src = img.getAttribute('data-src');
          
          if (src) {
            img.src = src;
            img.classList.add('loaded');
            observer.unobserve(img); // Stop observing once loaded
          }
        }
      });
    }, imageObserverOptions);
    
    // Start observing all lazy images
    lazyImages.forEach(img => imageObserver.observe(img));
  });
</script>
